/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export type GovernanceParametersStruct = {
  voteToken: PromiseOrValue<string>;
  radomRegistryDiamond: PromiseOrValue<string>;
  stakeDecimals: PromiseOrValue<BigNumberish>;
  minYes: [
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>
  ];
  quorum: [
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>,
    PromiseOrValue<BigNumberish>
  ];
  minProposalDuration: PromiseOrValue<BigNumberish>;
  proposalPeriod: PromiseOrValue<BigNumberish>;
  executionDelay: PromiseOrValue<BigNumberish>;
  proposalThreshold: PromiseOrValue<BigNumberish>;
};

export type GovernanceParametersStructOutput = [
  string,
  string,
  number,
  [number, number, number, number, number],
  [number, number, number, number, number],
  number,
  number,
  number,
  BigNumber
] & {
  voteToken: string;
  radomRegistryDiamond: string;
  stakeDecimals: number;
  minYes: [number, number, number, number, number];
  quorum: [number, number, number, number, number];
  minProposalDuration: number;
  proposalPeriod: number;
  executionDelay: number;
  proposalThreshold: BigNumber;
};

export type ProposalStruct = {
  proposalType: PromiseOrValue<BigNumberish>;
  yesVotes: PromiseOrValue<BigNumberish>;
  noVotes: PromiseOrValue<BigNumberish>;
  startTime: PromiseOrValue<BigNumberish>;
  endTime: PromiseOrValue<BigNumberish>;
  executionFromTime: PromiseOrValue<BigNumberish>;
  isCanceled: PromiseOrValue<boolean>;
  isExecuted: PromiseOrValue<boolean>;
  isQueued: PromiseOrValue<boolean>;
  proposer: PromiseOrValue<string>;
  argument: PromiseOrValue<BytesLike>;
  description: PromiseOrValue<string>;
};

export type ProposalStructOutput = [
  number,
  number,
  number,
  number,
  number,
  number,
  boolean,
  boolean,
  boolean,
  string,
  string,
  string
] & {
  proposalType: number;
  yesVotes: number;
  noVotes: number;
  startTime: number;
  endTime: number;
  executionFromTime: number;
  isCanceled: boolean;
  isExecuted: boolean;
  isQueued: boolean;
  proposer: string;
  argument: string;
  description: string;
};

export type ProposalResponseStruct = {
  proposalId: PromiseOrValue<BigNumberish>;
  proposalType: PromiseOrValue<BigNumberish>;
  yesVotes: PromiseOrValue<BigNumberish>;
  noVotes: PromiseOrValue<BigNumberish>;
  startTime: PromiseOrValue<BigNumberish>;
  endTime: PromiseOrValue<BigNumberish>;
  status: PromiseOrValue<BigNumberish>;
  proposer: PromiseOrValue<string>;
  argument: PromiseOrValue<BytesLike>;
  description: PromiseOrValue<string>;
};

export type ProposalResponseStructOutput = [
  BigNumber,
  number,
  number,
  number,
  number,
  number,
  number,
  string,
  string,
  string
] & {
  proposalId: BigNumber;
  proposalType: number;
  yesVotes: number;
  noVotes: number;
  startTime: number;
  endTime: number;
  status: number;
  proposer: string;
  argument: string;
  description: string;
};

export type ExecutionDataStruct = {
  isDelegateCall: PromiseOrValue<boolean>;
  target: PromiseOrValue<string>;
  value: PromiseOrValue<BigNumberish>;
  data: PromiseOrValue<BytesLike>;
};

export type ExecutionDataStructOutput = [boolean, string, BigNumber, string] & {
  isDelegateCall: boolean;
  target: string;
  value: BigNumber;
  data: string;
};

export declare namespace IDiamondCut {
  export type FacetCutStruct = {
    facetAddress: PromiseOrValue<string>;
    action: PromiseOrValue<BigNumberish>;
    functionSelectors: PromiseOrValue<BytesLike>[];
  };

  export type FacetCutStructOutput = [string, number, string[]] & {
    facetAddress: string;
    action: number;
    functionSelectors: string[];
  };
}

export interface RadomGovernanceInterface extends utils.Interface {
  functions: {
    "_proposals(uint64)": FunctionFragment;
    "cancelProposal(uint64)": FunctionFragment;
    "execute(uint64)": FunctionFragment;
    "getGovernanceParameters()": FunctionFragment;
    "getPaginatedProposals(uint64,uint64)": FunctionFragment;
    "getProposal(uint64)": FunctionFragment;
    "getProposalCount()": FunctionFragment;
    "getUserInfo(address)": FunctionFragment;
    "hasVoted(address,uint64)": FunctionFragment;
    "initialize((address,address,uint8,uint8[5],uint8[5],uint32,uint32,uint32,uint64))": FunctionFragment;
    "proposeChangeGovernanceParameters((address,address,uint8,uint8[5],uint8[5],uint32,uint32,uint32,uint64),string)": FunctionFragment;
    "proposeCodeExecution((bool,address,uint256,bytes),string)": FunctionFragment;
    "proposeDiamondChange((address,uint8,bytes4[])[],string)": FunctionFragment;
    "proposeOwnershipChange(address,string)": FunctionFragment;
    "proposeText(string)": FunctionFragment;
    "queue(uint64)": FunctionFragment;
    "stake(uint256)": FunctionFragment;
    "stakedBalances(address)": FunctionFragment;
    "transferStakedBalance(address,uint32)": FunctionFragment;
    "vote(uint64,bool)": FunctionFragment;
    "voteAndQueue(uint64,bool)": FunctionFragment;
    "withdraw(uint32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "_proposals"
      | "cancelProposal"
      | "execute"
      | "getGovernanceParameters"
      | "getPaginatedProposals"
      | "getProposal"
      | "getProposalCount"
      | "getUserInfo"
      | "hasVoted"
      | "initialize"
      | "proposeChangeGovernanceParameters"
      | "proposeCodeExecution"
      | "proposeDiamondChange"
      | "proposeOwnershipChange"
      | "proposeText"
      | "queue"
      | "stake"
      | "stakedBalances"
      | "transferStakedBalance"
      | "vote"
      | "voteAndQueue"
      | "withdraw"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "_proposals",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelProposal",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getGovernanceParameters",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPaginatedProposals",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposal",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getUserInfo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasVoted",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [GovernanceParametersStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeChangeGovernanceParameters",
    values: [GovernanceParametersStruct, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeCodeExecution",
    values: [ExecutionDataStruct, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeDiamondChange",
    values: [IDiamondCut.FacetCutStruct[], PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeOwnershipChange",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "proposeText",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "queue",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakedBalances",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "transferStakedBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "vote",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "voteAndQueue",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: "_proposals", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getGovernanceParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPaginatedProposals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hasVoted", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proposeChangeGovernanceParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeCodeExecution",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeDiamondChange",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeOwnershipChange",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposeText",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "queue", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "stakedBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferStakedBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "vote", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "voteAndQueue",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "ProposalCanceled(uint256)": EventFragment;
    "ProposalCreated(uint256,address,uint32,uint8,uint32,uint32,bytes,string)": EventFragment;
    "ProposalExecuted(uint256)": EventFragment;
    "ProposalQueued(uint256,uint32)": EventFragment;
    "Staked(address,uint256,uint32,address)": EventFragment;
    "StakedBalanceTransferred(address,address,uint32)": EventFragment;
    "Voted(uint256,address,bool,uint32,uint32)": EventFragment;
    "Withdrawn(address,uint256,uint32,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ProposalCanceled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalQueued"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Staked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakedBalanceTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Voted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdrawn"): EventFragment;
}

export interface ProposalCanceledEventObject {
  proposalId: BigNumber;
}
export type ProposalCanceledEvent = TypedEvent<
  [BigNumber],
  ProposalCanceledEventObject
>;

export type ProposalCanceledEventFilter =
  TypedEventFilter<ProposalCanceledEvent>;

export interface ProposalCreatedEventObject {
  proposalId: BigNumber;
  proposer: string;
  votes: number;
  proposalType: number;
  startTime: number;
  endTime: number;
  argument: string;
  description: string;
}
export type ProposalCreatedEvent = TypedEvent<
  [BigNumber, string, number, number, number, number, string, string],
  ProposalCreatedEventObject
>;

export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;

export interface ProposalExecutedEventObject {
  proposalId: BigNumber;
}
export type ProposalExecutedEvent = TypedEvent<
  [BigNumber],
  ProposalExecutedEventObject
>;

export type ProposalExecutedEventFilter =
  TypedEventFilter<ProposalExecutedEvent>;

export interface ProposalQueuedEventObject {
  proposalId: BigNumber;
  executionFromTime: number;
}
export type ProposalQueuedEvent = TypedEvent<
  [BigNumber, number],
  ProposalQueuedEventObject
>;

export type ProposalQueuedEventFilter = TypedEventFilter<ProposalQueuedEvent>;

export interface StakedEventObject {
  user: string;
  amountTokensDeposited: BigNumber;
  stakedAmount: number;
  token: string;
}
export type StakedEvent = TypedEvent<
  [string, BigNumber, number, string],
  StakedEventObject
>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface StakedBalanceTransferredEventObject {
  originAddress: string;
  destinationAddress: string;
  amount: number;
}
export type StakedBalanceTransferredEvent = TypedEvent<
  [string, string, number],
  StakedBalanceTransferredEventObject
>;

export type StakedBalanceTransferredEventFilter =
  TypedEventFilter<StakedBalanceTransferredEvent>;

export interface VotedEventObject {
  proposalId: BigNumber;
  voter: string;
  vote: boolean;
  yesVotes: number;
  noVotes: number;
}
export type VotedEvent = TypedEvent<
  [BigNumber, string, boolean, number, number],
  VotedEventObject
>;

export type VotedEventFilter = TypedEventFilter<VotedEvent>;

export interface WithdrawnEventObject {
  user: string;
  amountTokensWithdrawn: BigNumber;
  unstakedAmount: number;
  token: string;
}
export type WithdrawnEvent = TypedEvent<
  [string, BigNumber, number, string],
  WithdrawnEventObject
>;

export type WithdrawnEventFilter = TypedEventFilter<WithdrawnEvent>;

export interface RadomGovernance extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: RadomGovernanceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    _proposals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        number,
        number,
        number,
        number,
        number,
        number,
        boolean,
        boolean,
        boolean,
        string,
        string,
        string
      ] & {
        proposalType: number;
        yesVotes: number;
        noVotes: number;
        startTime: number;
        endTime: number;
        executionFromTime: number;
        isCanceled: boolean;
        isExecuted: boolean;
        isQueued: boolean;
        proposer: string;
        argument: string;
        description: string;
      }
    >;

    cancelProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getGovernanceParameters(
      overrides?: CallOverrides
    ): Promise<[GovernanceParametersStructOutput]>;

    getPaginatedProposals(
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[ProposalStructOutput[], BigNumber]>;

    getProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[ProposalResponseStructOutput]>;

    getProposalCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    getUserInfo(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number, number]>;

    hasVoted(
      user: PromiseOrValue<string>,
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    initialize(
      govParam: GovernanceParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    proposeChangeGovernanceParameters(
      govParam: GovernanceParametersStruct,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    proposeCodeExecution(
      executionData: ExecutionDataStruct,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    proposeDiamondChange(
      _facetCuts: IDiamondCut.FacetCutStruct[],
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    proposeOwnershipChange(
      newOwner: PromiseOrValue<string>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    proposeText(
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    queue(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stake(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stakedBalances(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    transferStakedBalance(
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    vote(
      proposalId: PromiseOrValue<BigNumberish>,
      _yesVote: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    voteAndQueue(
      proposalId: PromiseOrValue<BigNumberish>,
      _yesVote: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      _unstakeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  _proposals(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      number,
      number,
      number,
      number,
      number,
      number,
      boolean,
      boolean,
      boolean,
      string,
      string,
      string
    ] & {
      proposalType: number;
      yesVotes: number;
      noVotes: number;
      startTime: number;
      endTime: number;
      executionFromTime: number;
      isCanceled: boolean;
      isExecuted: boolean;
      isQueued: boolean;
      proposer: string;
      argument: string;
      description: string;
    }
  >;

  cancelProposal(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  execute(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getGovernanceParameters(
    overrides?: CallOverrides
  ): Promise<GovernanceParametersStructOutput>;

  getPaginatedProposals(
    offset: PromiseOrValue<BigNumberish>,
    limit: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<[ProposalStructOutput[], BigNumber]>;

  getProposal(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<ProposalResponseStructOutput>;

  getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

  getUserInfo(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[number, number]>;

  hasVoted(
    user: PromiseOrValue<string>,
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<number>;

  initialize(
    govParam: GovernanceParametersStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  proposeChangeGovernanceParameters(
    govParam: GovernanceParametersStruct,
    description: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  proposeCodeExecution(
    executionData: ExecutionDataStruct,
    description: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  proposeDiamondChange(
    _facetCuts: IDiamondCut.FacetCutStruct[],
    description: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  proposeOwnershipChange(
    newOwner: PromiseOrValue<string>,
    description: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  proposeText(
    description: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  queue(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stake(
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stakedBalances(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  transferStakedBalance(
    _to: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  vote(
    proposalId: PromiseOrValue<BigNumberish>,
    _yesVote: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  voteAndQueue(
    proposalId: PromiseOrValue<BigNumberish>,
    _yesVote: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    _unstakeAmount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    _proposals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        number,
        number,
        number,
        number,
        number,
        number,
        boolean,
        boolean,
        boolean,
        string,
        string,
        string
      ] & {
        proposalType: number;
        yesVotes: number;
        noVotes: number;
        startTime: number;
        endTime: number;
        executionFromTime: number;
        isCanceled: boolean;
        isExecuted: boolean;
        isQueued: boolean;
        proposer: string;
        argument: string;
        description: string;
      }
    >;

    cancelProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getGovernanceParameters(
      overrides?: CallOverrides
    ): Promise<GovernanceParametersStructOutput>;

    getPaginatedProposals(
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[ProposalStructOutput[], BigNumber]>;

    getProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<ProposalResponseStructOutput>;

    getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    getUserInfo(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number, number]>;

    hasVoted(
      user: PromiseOrValue<string>,
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<number>;

    initialize(
      govParam: GovernanceParametersStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    proposeChangeGovernanceParameters(
      govParam: GovernanceParametersStruct,
      description: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposeCodeExecution(
      executionData: ExecutionDataStruct,
      description: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposeDiamondChange(
      _facetCuts: IDiamondCut.FacetCutStruct[],
      description: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposeOwnershipChange(
      newOwner: PromiseOrValue<string>,
      description: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposeText(
      description: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    queue(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stake(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stakedBalances(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    transferStakedBalance(
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    vote(
      proposalId: PromiseOrValue<BigNumberish>,
      _yesVote: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    voteAndQueue(
      proposalId: PromiseOrValue<BigNumberish>,
      _yesVote: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      _unstakeAmount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ProposalCanceled(uint256)"(proposalId?: null): ProposalCanceledEventFilter;
    ProposalCanceled(proposalId?: null): ProposalCanceledEventFilter;

    "ProposalCreated(uint256,address,uint32,uint8,uint32,uint32,bytes,string)"(
      proposalId?: null,
      proposer?: PromiseOrValue<string> | null,
      votes?: null,
      proposalType?: null,
      startTime?: null,
      endTime?: null,
      argument?: null,
      description?: null
    ): ProposalCreatedEventFilter;
    ProposalCreated(
      proposalId?: null,
      proposer?: PromiseOrValue<string> | null,
      votes?: null,
      proposalType?: null,
      startTime?: null,
      endTime?: null,
      argument?: null,
      description?: null
    ): ProposalCreatedEventFilter;

    "ProposalExecuted(uint256)"(proposalId?: null): ProposalExecutedEventFilter;
    ProposalExecuted(proposalId?: null): ProposalExecutedEventFilter;

    "ProposalQueued(uint256,uint32)"(
      proposalId?: null,
      executionFromTime?: null
    ): ProposalQueuedEventFilter;
    ProposalQueued(
      proposalId?: null,
      executionFromTime?: null
    ): ProposalQueuedEventFilter;

    "Staked(address,uint256,uint32,address)"(
      user?: PromiseOrValue<string> | null,
      amountTokensDeposited?: null,
      stakedAmount?: null,
      token?: null
    ): StakedEventFilter;
    Staked(
      user?: PromiseOrValue<string> | null,
      amountTokensDeposited?: null,
      stakedAmount?: null,
      token?: null
    ): StakedEventFilter;

    "StakedBalanceTransferred(address,address,uint32)"(
      originAddress?: PromiseOrValue<string> | null,
      destinationAddress?: PromiseOrValue<string> | null,
      amount?: null
    ): StakedBalanceTransferredEventFilter;
    StakedBalanceTransferred(
      originAddress?: PromiseOrValue<string> | null,
      destinationAddress?: PromiseOrValue<string> | null,
      amount?: null
    ): StakedBalanceTransferredEventFilter;

    "Voted(uint256,address,bool,uint32,uint32)"(
      proposalId?: null,
      voter?: PromiseOrValue<string> | null,
      vote?: null,
      yesVotes?: null,
      noVotes?: null
    ): VotedEventFilter;
    Voted(
      proposalId?: null,
      voter?: PromiseOrValue<string> | null,
      vote?: null,
      yesVotes?: null,
      noVotes?: null
    ): VotedEventFilter;

    "Withdrawn(address,uint256,uint32,address)"(
      user?: PromiseOrValue<string> | null,
      amountTokensWithdrawn?: null,
      unstakedAmount?: null,
      token?: null
    ): WithdrawnEventFilter;
    Withdrawn(
      user?: PromiseOrValue<string> | null,
      amountTokensWithdrawn?: null,
      unstakedAmount?: null,
      token?: null
    ): WithdrawnEventFilter;
  };

  estimateGas: {
    _proposals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cancelProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getGovernanceParameters(overrides?: CallOverrides): Promise<BigNumber>;

    getPaginatedProposals(
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    getUserInfo(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    hasVoted(
      user: PromiseOrValue<string>,
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      govParam: GovernanceParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    proposeChangeGovernanceParameters(
      govParam: GovernanceParametersStruct,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    proposeCodeExecution(
      executionData: ExecutionDataStruct,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    proposeDiamondChange(
      _facetCuts: IDiamondCut.FacetCutStruct[],
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    proposeOwnershipChange(
      newOwner: PromiseOrValue<string>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    proposeText(
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    queue(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stake(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stakedBalances(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferStakedBalance(
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    vote(
      proposalId: PromiseOrValue<BigNumberish>,
      _yesVote: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    voteAndQueue(
      proposalId: PromiseOrValue<BigNumberish>,
      _yesVote: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdraw(
      _unstakeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    _proposals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancelProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getGovernanceParameters(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPaginatedProposals(
      offset: PromiseOrValue<BigNumberish>,
      limit: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getProposalCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getUserInfo(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    hasVoted(
      user: PromiseOrValue<string>,
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      govParam: GovernanceParametersStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    proposeChangeGovernanceParameters(
      govParam: GovernanceParametersStruct,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    proposeCodeExecution(
      executionData: ExecutionDataStruct,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    proposeDiamondChange(
      _facetCuts: IDiamondCut.FacetCutStruct[],
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    proposeOwnershipChange(
      newOwner: PromiseOrValue<string>,
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    proposeText(
      description: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    queue(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stake(
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stakedBalances(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferStakedBalance(
      _to: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    vote(
      proposalId: PromiseOrValue<BigNumberish>,
      _yesVote: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    voteAndQueue(
      proposalId: PromiseOrValue<BigNumberish>,
      _yesVote: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      _unstakeAmount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
